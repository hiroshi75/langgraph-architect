# プロンプト最適化の優先順位

改善のインパクトが大きい順に最適化テクニックを適用するための優先順位ガイド。

## 📊 最適化の優先順位

改善のインパクトが大きい順：

### 1. Few-Shot Examples 追加（高インパクト、低コスト）
- **改善**: Accuracy +10-20%
- **コスト**: +5-10% (input tokens 増加)
- **実装時間**: 30分-1時間
- **推奨**: ⭐⭐⭐⭐⭐

### 2. 出力フォーマット構造化（高インパクト、低コスト）
- **改善**: Latency -10-20%, Parsing errors -90%
- **コスト**: ±0%
- **実装時間**: 15-30分
- **推奨**: ⭐⭐⭐⭐⭐

### 3. Temperature/Max Tokens 調整（中インパクト、ゼロコスト）
- **改善**: Latency -10-30%, Cost -20-40%
- **コスト**: 削減
- **実装時間**: 10-15分
- **推奨**: ⭐⭐⭐⭐⭐

### 4. 明確な指示とガイドライン（中インパクト、低コスト）
- **改善**: Accuracy +5-10%, Quality +15-25%
- **コスト**: +2-5%
- **実装時間**: 30分-1時間
- **推奨**: ⭐⭐⭐⭐

### 5. モデル選択の最適化（高インパクト、要検証）
- **改善**: Cost -40-60%
- **リスク**: Accuracy -2-5%
- **実装時間**: 2-4時間（検証含む）
- **推奨**: ⭐⭐⭐⭐

### 6. プロンプトキャッシング（高インパクト、中コスト）
- **改善**: Cost -50-90% (キャッシュヒット時)
- **複雑性**: 中（実装とモニタリング）
- **実装時間**: 1-2時間
- **推奨**: ⭐⭐⭐⭐

### 7. Chain-of-Thought（特定タスクで高インパクト）
- **改善**: Complex tasks で Accuracy +15-30%
- **コスト**: +20-40%
- **実装時間**: 1-2時間
- **推奨**: ⭐⭐⭐ (complex tasks のみ)

### 8. Self-Consistency（限定的な使用）
- **改善**: Accuracy +10-20%
- **コスト**: +200-300%
- **実装時間**: 2-3時間
- **推奨**: ⭐⭐ (critical decisions のみ)

## 🔄 反復的な最適化プロセス

```
1. ベースライン測定
   ↓
2. 最もインパクトの大きい改善を選択
   ↓
3. 実装（1つの変更のみ）
   ↓
4. 評価（同じテストケースで）
   ↓
5. 改善が確認されたか？
   ├─ Yes → 変更を保持、ステップ2へ
   └─ No → 変更をロールバック、別の改善を試す
   ↓
6. 目標達成？
   ├─ Yes → 完了
   └─ No → ステップ2へ
```

## まとめ

効果的なプロンプト最適化のために：

1. ✅ **明確性**: 役割、タスク、出力形式を明確に
2. ✅ **Few-Shot Examples**: 3-7個の良質な例
3. ✅ **構造化**: JSON などの構造化された出力
4. ✅ **パラメータ調整**: タスクに応じた temperature/max_tokens
5. ✅ **段階的改善**: 1度に1つの変更、測定、検証
6. ✅ **コスト意識**: モデル選択、キャッシング、max_tokens
7. ✅ **測定駆動**: すべての変更を定量的に評価
